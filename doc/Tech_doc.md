# BeanCKUP CLI 技术架构文档

**版本**: v2.1 (并发与健壮性修复版)
**目标**: 为开发者提供一份全面、深入的内部技术参考，确保项目的可维护性和可扩展性。

## 一、 核心设计哲学

BeanCKUP 的设计遵循以下原则：

1.  **数据完整性优先**：所有设计都以确保备份和恢复的绝对可靠为首要目标。增量逻辑、清单系统和恢复流程都必须是确定性的，无任何模糊逻辑。
2.  **性能与效率**：在保证可靠性的前提下，通过并发和优化的算法，最大化利用硬件性能，提升用户体验。
3.  **状态与操作分离**：程序的核心是管理状态（`types.go`中定义的数据结构），而各个模块（`indexer`, `restorer`等）则是对这些状态进行操作的无状态服务。
4.  **明确的职责边界**：每个模块只做一件事，并通过清晰的函数接口与其他模块协作。

## 二、 核心数据结构 (`internal/types.go`)

这是整个系统的基石。

-   **`FileNode`**: 代表一个文件或目录在某个时间点的状态。
    * `Path`: `string` - 文件在工作区的**当前**相对路径。这是文件的“逻辑身份”。
    * `Hash`: `string` - 文件的SHA256哈希，是文件内容的“唯一指纹”。
    * **`Reference`**: `string` - **【核心字段】** 指向该文件物理实体所在的位置。格式为 `packagename.7z/path/in/package.jpg`。
        * 对于**新文件**，在打包时该值被设置为 `自己所在的包名/自己的Path`。
        * 对于**引用文件**，该值继承自历史记录，指向它最初被打包时的位置。
        * 这是恢复流程的**唯一依据**。

-   **`HistoricalState`**: 在扫描开始前，通过加载所有历史清单构建的内存数据库。
    * `PathToNode`: `map[string]*FileNode` - 快速通过文件**路径**查找其上一次的完整状态。用于五元预筛。
    * `HashToNode`: `map[string]*FileNode` - 快速通过文件**哈希**查找其最原始的节点信息（包含最原始的Reference）。用于识别移动文件和设置引用。

-   **`Plan` / `Episode`**: 交付计划。`Plan`代表一次完整的交付会话，包含多个`Episode`。每个`Episode`对应一个将要生成的`.7z`交付包，里面只包含**需要物理打包的新文件**。

-   **`Manifest`**: 交付清单。每个`.7z`交付包都内含一个。它记录了**执行完本次交付后，工作区的完整文件列表**，包括所有新文件和所有引用文件及其`Reference`。

## 三、 关键模块工作流程

### 1. `indexer` (并发扫描模块)

-   **目标**: 高效、准确地扫描工作区，为每个文件生成一个包含正确 `Reference` 的 `FileNode`。
-   **流程 (`ScanWithProgress`)**:
    1.  **生产者**: 主协程（goroutine）使用 `filepath.Walk` 快速遍历文件系统。它不进行任何耗时操作，只将发现的文件路径和信息封装成 `Job`，推入一个带缓冲的 `jobs` 通道。
    2.  **消费者 (Workers)**: 程序根据CPU核心数启动多个工作协程。每个协程循环地从 `jobs` 通道中取出任务。
    3.  **并行处理**: 每个工作协程独立地对获取到的文件执行 `classifyFile` 函数。
        * **`classifyFile` 逻辑**:
            a.  **五元预筛**: 使用 `history.PathToNode` 检查文件的路径、大小、时间戳是否完全未变。若是，则直接继承历史`FileNode`的所有信息（包括`Hash`和`Reference`），跳过后续步骤。
            b.  **计算哈希**: 若预筛失败，则计算文件的SHA256哈希。
            c.  **哈希比对**: 使用 `history.HashToNode` 检查该哈希是否存在于历史中。
                -   若**存在**，说明文件内容未变（只是被移动/重命名），则从历史记录中继承其最原始的 `Reference`。
                -   若**不存在**，说明这是一个真正的新增或被修改的文件，其 `Reference` 字段暂时**留空**。
    4.  **结果收集**: 所有`FileNode`结果被送入`results`通道，主协程负责收集，最终返回完整的节点列表。

### 2. `main` (主流程编排) & `session` (计划管理)

-   **目标**: 基于`indexer`的扫描结果，创建交付计划并驱动整个交付过程。
-   **流程 (`handleScanAndDeliver` -> `executeDeliveryLoop`)**:
    1.  调用 `indexer` 获取 `allNodes`。
    2.  调用 `session.CreatePlan`。此函数现在只做一件事：遍历 `allNodes`，筛选出所有 `Reference` 为空的文件（即新文件），然后根据大小限制将它们分配到不同的 `Episode` 中。
    3.  进入 `executeDeliveryLoop` 循环。对每个待处理的 `Episode`：
        a.  **生成包名**: 为当前 `Episode` 生成一个唯一的、带时间戳的包名（如 `workspace-S2E1-xxxx.7z`）。
        b.  **构建清单 (`Manifest`)**:
            -   **文件列表**: 清单的文件列表包含两部分：
                1.  当前 `Episode` 中的所有新文件。
                2.  **如果这是E01包**，则额外追加 `allNodes` 中所有 `Reference` 不为空的文件（即所有引用文件）。
            -   **设置引用**: 在构建清单时，对所有 `Reference` 为空的新文件，将其 `Reference` 字段设置为 `生成的包名/文件自己的Path`。
        c.  **物理打包**: 调用 `packager.CreatePackage`。**关键点**：传递给打包器的文件列表**仅为当前 `Episode` 中的文件**（`episode.Files`），因为只有这些是需要物理压缩的。
        d.  **保存清单**: 打包成功后，将生成的 `Manifest` 保存到 `.beanckup` 目录中。

### 3. `packager` (“直接提货单”打包模块)  #旧，可能不准确，请以实际代码为准。 

-   **目标**: 高效、可靠地创建交付包，避免不必要的I/O和对用户系统盘的写入。
-   **流程 (`CreatePackage`)**:
    1.  **创建本地元数据目录**: 在操作系统的**默认临时目录**（如 `C:\Users\...\Temp`）创建一个极小的临时文件夹。这个文件夹只用于存放本次打包的“元数据”，不存放任何源文件。
    2.  **生成清单**: 将动态生成的 `manifest.json` 写入这个本地临时目录。
    3.  **生成提货单**: 创建一个 `listfile.txt`，里面写入所有需要打包的源文件的**绝对路径**（例如 `A:\vacation\hawaii.jpg`）。
    4.  **打包源文件 (第一步)**: 调用 `7z a` 命令，并附带两个关键参数：
        * `@listfile.txt`: 让 7z 根据提货单去读取文件。
        * `-w{workspaceRoot}`: 将 7z 的工作目录设置为您的源文件工作区（如 `A:\`）。这会使 7z 自动去除绝对路径前缀，只在包内保留相对路径（`vacation\hawaii.jpg`），从而保证了路径的干净。
        * 这个过程实现了**从硬盘A直接读取，向硬盘B直接写入压缩包**。
    5.  **更新压缩包 (第二步)**: 调用 `7z u` (update) 命令，将本地临时目录中的 `.beanckup/manifest.json` 添加/更新到刚刚生成的压缩包中。
    6.  **清理**: 删除本地的临时元数据目录。

### 4. `restorer` (可靠恢复模块)

-   **目标**: 精确、可靠地从交付包中恢复工作区在指定时间点的全貌。
-   **流程 (`RestoreFromSession`)**:
    1.  **加载目标清单**: 加载用户选择的会话（Session）对应的所有 `Manifest` 文件，并将它们合并，构建出一个目标时间点工作区的最终文件列表 `finalFileSet`。
    2.  **恢复历史记录**: 将该会话及之前所有历史会话的 `Manifest` 文件，全部恢复到新恢复目录下的 `.beanckup` 文件夹中。
    3.  **按源包分组**: 遍历 `finalFileSet`，根据每个文件的 `Reference` 字段，将它们按其物理所在的源包（`packagename.7z`）进行分组。
    4.  **批量解压**: 对每个分组（即每个源包），执行一次 `7z` 命令。
        * **临时目录**: 在**最终恢复目录内**创建一个临时文件夹（如 `.beanckup_temp_restore`），避免跨盘问题。
        * **文件列表**: 将该分组内所有文件在包内的路径（`path/in/package.jpg`）写入一个临时列表文件。
        * **执行解压**: 调用 `7z x ... @listfile.txt`，将所需文件批量、精确地解压到上述临时目录。
    5.  **移动文件**: 遍历该分组的文件，将它们从临时目录移动（`os.Rename`）到其在恢复目录中的最终逻辑路径。由于源和目标都在同一磁盘，此操作效率极高且不会失败。
    6.  **清理**: 恢复完成后，删除临时目录。

## 四、快速上手指南

1.  **环境依赖**:
    * Go 语言环境 (1.18+)
    * 7-Zip 命令行工具 (已加入系统 PATH)

2.  **编译**:
    ```sh
    go build -o beanckup-cli main.go
    ```

3.  **备份**:
    * 运行 `./beanckup-cli`
    * 选择 `1. 扫描和交付（备份）`
    * 按提示输入**工作区路径**。
    * 程序自动扫描并显示结果。
    * 按提示输入**交付参数**（保存路径、分卷大小、密码等）。
    * 确认后开始交付。

4.  **恢复**:
    * 运行 `./beanckup-cli`
    * 选择 `2. 恢复文件`
    * 输入**交付包所在的目录**。
    * 选择需要恢复的**历史会话**。
    * 输入密码（如有）。
    * 输入**恢复目标路径**（一个新目录）。
    * 确认后开始恢复。
